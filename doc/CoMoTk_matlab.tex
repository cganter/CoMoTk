% Created 2020-08-05 Mi 18:05
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{etoolbox}
\usepackage{tcolorbox}
\BeforeBeginEnvironment{lstlisting}{\begin{tcolorbox}}
\AfterEndEnvironment{lstlisting}{\end{tcolorbox}}
\setlength{\voffset}{-2cm}
\setlength{\hoffset}{-1.5cm}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.8cm}
\makeatletter
\g@addto@macro \normalsize {
\setlength\abovedisplayskip{15pt plus 3pt minus 3pt}
\setlength\belowdisplayskip{15pt plus 3pt minus 3pt}
\setlength\abovedisplayshortskip{3pt plus 3pt}
\setlength\belowdisplayshortskip{10pt plus 3pt minus 4pt}
}
\makeatother
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\renewenvironment{LaTeX}{}{}
\renewcommand\refname{}
\author{Carl Ganter}
\date{\today}
\title{CoMoTk Matlab User Guide}
\hypersetup{
 pdfauthor={Carl Ganter},
 pdftitle={CoMoTk Matlab User Guide},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3.7)}, 
 pdflang={English}}
\begin{document}

\maketitle
In addition to the comments in the code and the provided (highly recommended) examples, 
this short document contains some additional tips, how to use the configuration model (CM) toolkit
\texttt{CoMoTk}. It does \textbf{not} explain the underlying CM formalism, which is done extensively
in a separate article (link will be provided, as soon as it becomes accessible).  

\section{Initialize \texttt{CoMoTk}}
\label{sec:orgdda15da}
First, we need to create an instance of \texttt{CoMoTk}:

\begin{verbatim}
cm = CoMoTk;
\end{verbatim}

Next, we have to setup a few mandatory tissue parameters. In the simpliest case
of a 1-peak model without diffusion, this can look like this:

\begin{verbatim}
cm.R1 = 0.01;       % longitudinal relaxation rate
cm.R2 = 0.1;        % transverse relaxation rate
cm.D = 0;           % apparent diffusion coefficient
\end{verbatim}

It is also possible to specify more complex n-peak models with variable relative 
proton density, chemical shift and diffusivity (which can also be supplied as a tensor in case of anisotropic diffusion). 

Here, a 2-peak example:

\begin{verbatim}
cm.R1 = [ 0.01, 0.02 ];
cm.R2 = [ 0.1, 0.2 ];
cm.D = [ 3, 1.5 ];
cm.mu = [ 0.6, 0.4 ];    % relative proton density (does not need to add to 1)
cm.dom = [ 0, -0.1 ];    % chemical shift (angular frequency)
cm.k = [ -2, 3; 2, -3 ]; % transition rates for magnetization transfer/exchange
\end{verbatim}

Setting \texttt{w}, \texttt{dom} and \texttt{k} is optional. If not set, they default to \texttt{1}, \texttt{0} and \texttt{[]}, respectively.

Another optional variable is the relative \(B_1^+\) field (default = 1):

\begin{verbatim}
cm.B1 = 0.8;
\end{verbatim}

There are further options to modify the default settings. The most important
one is the desired accuracy \texttt{epsilon}. A nonzero value restricts the number of stored
configurations (at the cost of accuracy), which can be reasonable to prevent memory overflow and/or to reduce the computation 
time.

\begin{verbatim}
options = cm.options;    % get default options

options.alloc_d = 3;            % allocated number of dimensions
options.alloc_n = 10000;        % allocated number of configurations
options.epsilon = 1e-4;         % trade accuracy against speed and/or memory
options.rapid_meltdown = false; % choice of acceleration technique
options.verbose = true;         % for more output
options.debug = true;           % for debugging purposes (look into CoMoTk.m)

cm.options = options;    % activate new options
\end{verbatim}

Now we have to specify the initial configuration vector, corresponding to configuration order \(\bm{n} = 0\). 
It is supplied as a real vector (row or column) in the usual convention \(\left( m_x, m_y, m_z \right)\):

\begin{verbatim}
cm.init_configuration ( [ 0; 0; 1 ] );  % longitudinal magnetization
\end{verbatim}

In addition to the actual state (expressed by all the configuration vectors), knowledge of certain partial derivatives 
is sometimes desired as well, e.g. for numerical optimization.
This is supported in \texttt{CoMoTk} for several tissue and sequence parameters. 
To get familiar with this concept, the best strategy may be to first look into the provided script \texttt{test\_derivatives.m} and
for more details into the class definition \texttt{CoMoTk.m}.

After having initialized everything, we proceed with the actual sequence. 

\section{Execute Sequence}
\label{sec:org4ffa444}

\subsection{RF pulse}
\label{sec:orgc87c325}
Executing an (instantaneous) RF pulse is as simple as:

\begin{verbatim}
param = [];
param.FlipAngle = pi / 2;
param.Phase = 0;

cm.RF( param );                % execute instantaneous RF pulse
\end{verbatim}

Additional parameters may be supplied to \texttt{param}, if partial derivatives with respect to flip angle and/or phase are required
or in case of magnetization transfer. See the comments and implementation in \texttt{CoMoTk.m} for more details 

\subsection{Time interval}
\label{sec:orgeabb177}
Executing a time interval of duration \texttt{tau}, zero-order gradient moment \texttt{p}, and identified by some unique integer index
\texttt{lambda}, works like this:

\begin{verbatim}
param = [];
param.lambda = 1;              % this field is always required
param.tau = 0.5;               % required only in first call
param.p = [ 0.1, -0.8, 0.5 ];  % optional, specification in first call is sufficient

cm.time( param );              % execute time interval
\end{verbatim}

The field \texttt{param.p} is optional, unless the diffusion constant/tensor is nonzero.

Depending on the context, it may be necessary, to add further parameters to \texttt{param} 
(e.g. more details about the gradient shape or to specify bulk motion).
For details, look at the examples and the code (which also contains some informative comments).

\subsection{Spoiler}
\label{sec:orga5ea769}
An ideal spoiler is a zero duration event, which just eliminates any transverse magnetization. This can be useful to simulate
a simplified sequence behaviour (like ideal RF spoiling).
It does not require any parameters and is simply invoked as follows:

\begin{verbatim}
cm.spoiler;                    % execute ideal instantaneous spoiler
\end{verbatim}

\section{Get results}
\label{sec:orgdbccbdc}
The CM is applicable to arbitrary sequences and tissues. Interpretation of the results of therefore  
depends very much on the assumptions of the simulation. To become familiar with the possible
approaches, it is therefore crucial to study the CM manuscript and the provided example scripts (which were actually used 
to generate the figures in the manuscript).

Here, we can only sketch the general strategy:

\subsection{Select relevant magnetization pathways \dots{}}
\label{sec:orgdb0c650}

The reconstructed signal typically corresponds to some weighted sum over all or
a subset of stored configurations.
Specific subsets can be extracted with a separate method

\begin{verbatim}
b_n = cm.find( lambda, n );
\end{verbatim}

The elements of the arrays \texttt{n} and \texttt{lambda}, specify the selected configuration orders and the associated CM dimensions, 
respectively.

To realize more complicated AND/OR conditions, the (OR-type) \texttt{find} method (which returns a boolean array)
can be called multiple times with different arguments and the results can be combined with operators \texttt{\&} and \texttt{|}. 

The full set of actually stored configurations is always stored in the boolean array \texttt{cm.b\_n}:

\begin{verbatim}
b_n = cm.b_n;
\end{verbatim}

\subsection{\dots{} and calculate their (weighted) sum}
\label{sec:org3b3bc34}

Once the subset has been specified in \texttt{b\_n}, the weighted sum can then be calculated like this

\begin{verbatim}
param = [];
param.b_n = b_n;

res = cm.sum( param );
\end{verbatim}

The result is returned separately as complex transverse (\texttt{res.xy}) and longitudinal (\texttt{res.z}) component.

The structure \texttt{param} has more optional fields:

\begin{description}
\item[{\texttt{omega} =}] Local angular off-resonance frequency \(\omega\left(\bm{x}\right)\)
\item[{\texttt{x} =}] Position \(\bm{x}\)
\item[{\texttt{w\_n} =}] explicit weighting factors (\texttt{length( w\_n ) = sum( b\_n )})
\end{description}

For unset fields, the following defaults are assumed:

\begin{itemize}
\item \texttt{omega} \(= 0\)
\item \texttt{x} \(= 0\)
\item \texttt{b\_n} \(=\) \texttt{cm.b\_n}
\item \texttt{w\_n} \(= 1\)
\end{itemize}

In addition, arbitrary effects due to inhomogeneous broadening (e.g. caused by susceptibility variations) can be included by 
supplying a function handle to the field \texttt{cm.inhomogeneous\_decay}. See the script \texttt{bssfp\_susc.m} for an example. 

Accordingly, any calculated derivatives with respect to \texttt{X} are returned as \texttt{res.dm\_dX.xy} and \texttt{res.dm\_dX.z}. 
\end{document}
